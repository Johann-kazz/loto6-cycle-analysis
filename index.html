<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ロト6,7 周期性分析 v2（論理合成つき）</title>
    <!-- ▼ Favicon を追加 ▼ -->
  <link rel="icon" type="image/png" sizes="16x16" href="images/loto_favicon_16x16.png">
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    .mono { font-feature-settings: "tnum" on; }
    .section-hidden { display: none; }
    .chip { padding: 0.125rem 0.5rem; border-radius: 0.5rem; border: 1px solid rgb(226,232,240); background: #f8fafc; }
    .chip-hi { background: #ecfdf5; border-color: #6ee7b7; color: #047857; }
    th.sticky-th { position: sticky; top: 0; background: #f1f5f9; z-index: 1; }
    .btn-outline-primary.active{ color:#fff; background-color:#0d6efd; }

    /* ===== スマホで押しやすいよう 論理合成(β) を大型化 ===== */
    .tap-btn{padding:0.75rem 1rem;font-size:1.05rem;line-height:1.2;min-width:68px;border-radius:0.8rem}
    .tap-btn-operator{font-weight:600}
    .op-grid{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:0.5rem}
    .op-grid .btn{width:100%}
    .logic-toolbar .form-control{height:3.125rem;font-size:1.05rem}
    @media(min-width:768px){.op-grid{grid-template-columns:repeat(6,minmax(0,1fr))}}
    .op-btn{min-width:96px}
    #logicBuilder #logicOperands .btn{min-width:96px;padding:0.65rem 0.9rem;font-size:1.05rem;border-radius:0.8rem}
    #logicBuilder .input-group .btn{padding:0.75rem 1rem;font-size:1.05rem}
    #logicBuilder .input-group .form-control{height:3.125rem;font-size:1.05rem}
    /* ===== ヘッダーカード 背景色 黄色 ===== */
    .header-card {
      background-color: rgba(255, 255, 0, 0.541);
      padding: 1rem;
    }
  </style>
  <!-- Bootstrap 5.3 -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <script defer src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
</head>
<body class="bg-slate-50 text-slate-800">
  <header class="bg-white border-b sticky top-0 z-10">
    <!---<div class="header-card">--->
    <div class="max-w-6xl mx-auto px-4 py-3 flex items-center justify-between">
      <h1 class="text-lg md:text-2xl font-bold flex items-center justify-center gap-2">
        <span style="font-size:0.7em;">ロト6,7 周期性分析 v2 </span>
        <img src='images/loto_analysis_logo.png' alt='LOTO Analysis' class='h-8 md:h-10 inline-block mr-2'>
      </h1>
      <nav class="text-sm d-flex gap-2">
        <button id="tabNormal"  class="btn btn-outline-primary btn-sm active" type="button">通常分析</button>
        <button id="tabShift"   class="btn btn-outline-primary btn-sm"           type="button">ずらし検証</button>
        <button id="tabPredict" class="btn btn-outline-primary btn-sm"           type="button">予測 v2</button>
        <button id="tabStats"   class="btn btn-outline-primary btn-sm"           type="button">組合せ統計</button>
      </nav>
    </div>
  </header>

  <main id="main" class="max-w-6xl mx-auto px-4 py-6 space-y-6">
    <!-- 通常分析 -->
    <section id="sectionNormal" class="bg-white rounded-xl shadow p-4 md:p-6 space-y-4">
      <h2 class="font-semibold">通常分析：最新回 × 直近N回</h2>
      <div class="grid md:grid-cols-5 gap-6 items-start">
        <div class="md:col-span-3"><canvas id="barChart" height="220"></canvas></div>
        <div class="md:col-span-2 space-y-3">
          <div><h3 class="font-semibold">最新回</h3><div id="latestNumbers" class="flex flex-wrap gap-2"></div></div>
          <div><h3 class="font-semibold">ウィンドウ別の一致</h3><div id="resultList" class="space-y-2 text-sm"></div></div>
        </div>
      </div>
      <p id="normalStatus" class="text-sm text-slate-500"></p>
      <div class="flex flex-wrap gap-3 items-end text-sm">
        <label>st <input id="stInput" type="number" value="2" min="1" class="w-16 border rounded px-2 py-1" /></label>
        <label>ed <input id="edInput" type="number" value="4" min="1" class="w-16 border rounded px-2 py-1" /></label>
        <label>直近N（追加してチェック）
          <input id="addRange" type="number" min="1" class="w-24 border rounded px-2 py-1" placeholder="N回" />
          <button id="addRangeBtn" class="px-3 py-1.5 rounded bg-indigo-600 text-white">追加</button>
        </label>
        <button id="selectCommon" class="px-3 py-1.5 rounded bg-slate-100 hover:bg-slate-200">よく使う</button>
        <button id="selectClear" class="px-3 py-1.5 rounded bg-slate-100 hover:bg-slate-200">全解除</button>
        <button id="runNormal" class="ml-auto px-4 py-2 rounded bg-indigo-600 text-white">通常分析を実行</button>
      </div>
      <div id="rangesBox" class="grid grid-cols-3 gap-2 text-sm"></div>
    </section>

    <!-- ずらし検証 -->
    <section id="sectionShift" class="bg-white rounded-xl shadow p-4 md:p-6 space-y-4 section-hidden">
      <h2 class="font-semibold">ずらし検証：各開催回 × 直前N回</h2>
      <div class="grid md:grid-cols-5 gap-6 items-start">
        <div class="md:col-span-3"><canvas id="shiftChart" height="220"></canvas></div>
        <div class="md:col-span-2 overflow-x-auto">
          <table id="shiftTable" class="min-w-full border text-sm">
            <thead class="bg-slate-100">
              <tr><th class="border px-2 py-1">対象回(最新からx回前)</th><th class="border px-2 py-1">的中数</th><th class="border px-2 py-1">的中数字</th></tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>
      <p id="shiftStatus" class="text-sm text-slate-500"></p>
      <div class="flex flex-wrap gap-3 items-end">
        <label class="text-sm">N（直前回数）<input id="shiftN" type="number" value="6" min="1" class="w-24 border rounded px-2 py-1" /></label>
        <label class="text-sm">最大ずらしX（0=最新回）<input id="shiftMax" type="number" value="20" min="0" class="w-28 border rounded px-2 py-1" /></label>
        <label class="text-sm">st<input id="shiftSt" type="number" value="2" min="1" class="w-20 border rounded px-2 py-1" /></label>
        <label class="text-sm">ed<input id="shiftEd" type="number" value="4" min="1" class="w-20 border rounded px-2 py-1" /></label>
        <button id="runShift" class="ml-auto px-4 py-2 rounded bg-indigo-600 text-white hover:bg-indigo-700">ずらし検証実行</button>
      </div>
    </section>

    <!-- 予測 v2（論理合成つき） -->
    <section id="sectionPredict" class="bg-white rounded-xl shadow p-4 md:p-6 space-y-4 section-hidden">
      <h2 class="font-semibold">予測 v2：窓の集合に対して自由な論理合成（AND/OR/差/NOT + 括弧）</h2>
      <div class="grid md:grid-cols-5 gap-6 items-start">
        <div class="md:col-span-3 space-y-3" id="predLists"></div>
        <div class="md:col-span-2 space-y-4">
          <div><h3 class="font-semibold flex items-center gap-2">AND（従来機能）<button id="btnRecalcAND" class="ml-2 px-2 py-1 rounded bg-slate-100 hover:bg-slate-200 text-sm">ANDを再計算</button></h3><div id="predAND" class="flex flex-wrap gap-1"></div></div>
          <div><h3 class="font-semibold">多数決（k本以上の窓で採用）</h3><div id="predMAJ" class="flex flex-wrap gap-1"></div></div>
          <div><h3 class="font-semibold">スコア付き一覧（フィルタ＆並べ替え後）</h3><div id="predSCORES" class="flex flex-wrap gap-1"></div></div>
        </div>
      </div>
      <p id="predStatus" class="text-sm text-slate-500"></p>
      <div class="grid md:grid-cols-3 gap-4">
        <div class="space-y-3 text-sm md:col-span-2">
          <div class="flex flex-wrap gap-3 items-end">
            <label>st <input id="predSt" type="number" value="2" min="1" class="w-16 border rounded px-2 py-1" /></label>
            <label>ed <input id="predEd" type="number" value="4" min="1" class="w-16 border rounded px-2 py-1" /></label>
            <label>直近N（追加してチェック）<input id="predAddRange" type="number" min="1" class="w-24 border rounded px-2 py-1" placeholder="N回" /><button id="predAddRangeBtn" class="px-3 py-1.5 rounded bg-indigo-600 text-white">追加</button></label>
          </div>
          <div class="flex flex-wrap gap-2"><button id="predSelectCommon" class="px-3 py-1.5 rounded bg-slate-100 hover:bg-slate-200">よく使う</button><button id="predSelectClear"  class="px-3 py-1.5 rounded bg-slate-100 hover:bg-slate-200">全解除</button><button id="runPredict" class="ml-auto px-4 py-2 rounded bg-indigo-600 text-white">予測を実行</button></div>
          <div id="predRangesBox" class="grid grid-cols-2 md:grid-cols-4 gap-2 text-sm"></div>
        </div>
        <div class="space-y-3 text-sm">
          <div class="flex flex-wrap gap-3 items-end"><label>AND 対象（チェックの付いたNだけ）<button id="andSelectAll" class="ml-2 px-2 py-1 rounded bg-slate-100 hover:bg-slate-200">全選択</button><button id="andSelectNone" class="ml-1 px-2 py-1 rounded bg-slate-100 hover:bg-slate-200">全解除</button></label></div>
          <div class="space-y-2">
            <div class="flex items-end gap-3"><label class="flex items-center gap-2">多数決しきい値 k（k本以上の窓で採用）<input id="voteK" type="number" value="2" min="1" class="w-24 border rounded px-2 py-1" /></label></div>
            <div class="flex flex-wrap gap-3 items-end"><label>並べ替え<select id="sortMode" class="border rounded px-2 py-1"><option value="windowsThenTotal">窓出現数→総出現数→数値</option><option value="totalThenWindows">総出現数→窓出現数→数値</option><option value="numeric">数値昇順</option></select></label></div>
            <div class="flex flex-wrap gap-3 items-end"><label>順序<select id="sortDir" class="border rounded px-2 py-1"><option value="desc">降順</option><option value="asc">昇順</option></select></label></div>
            <div class="space-y-2"><div class="font-medium text-sm">除外フィルタ（直近M回での出現回数に基づく）</div><div class="flex items-center gap-2"><span>直近</span><input id="filterM" type="number" value="6" min="1" class="w-20 border rounded px-2 py-1" /><span>回の範囲で</span></div><div class="flex items-center gap-2"><input id="filterMin" type="number" value="0" min="0" class="w-20 border rounded px-2 py-1" /><span>～</span><input id="filterMax" type="number" value="99" min="0" class="w-20 border rounded px-2 py-1" /><span>回 以外を除外</span></div></div>
          </div>
        </div>
      </div>

      <!-- ▼▼ 論理合成(β)：式ビルダー ▼▼ -->
      <div class="border-t pt-6 mt-2 space-y-4" id="logicBuilder">
        <h3 class="font-semibold flex items-center gap-2">論理合成(β) — 表現式で候補を合成 <span class="badge bg-primary-subtle text-primary-emphasis border border-primary-subtle">新機能</span></h3>
        <div class="text-sm text-slate-600">例: <code>(N=6 & N=9) - N=12</code> / <code>!(N=6 | N=9)</code>（! は補集合）</div>

        <div class="row g-2">
          <div class="col-12 col-md-7">
            <label class="form-label mb-1">式（タップで追記できます）</label>
            <div class="input-group mb-2 logic-toolbar">
              <input id="logicExpr" class="form-control form-control-lg" placeholder="(N=6 & N=9) - N=12 など" />
              <button id="logicBack" class="btn btn-outline-secondary tap-btn" title="1文字削除">⌫</button>
              <button id="logicClear" class="btn btn-outline-secondary tap-btn" title="クリア">クリア</button>
              <button id="logicEval" class="btn btn-primary tap-btn" title="評価">評価</button>
            </div>
            <div class="op-grid mb-2">
              <button data-op="(" class="btn btn-outline-secondary tap-btn tap-btn-operator">(</button>
              <button data-op=")" class="btn btn-outline-secondary tap-btn tap-btn-operator">)</button>
              <button data-op="&" class="btn btn-outline-secondary tap-btn tap-btn-operator">AND</button>
              <button data-op="|" class="btn btn-outline-secondary tap-btn tap-btn-operator">OR</button>
              <button data-op="-" class="btn btn-outline-secondary tap-btn tap-btn-operator">DIFF</button>
              <button data-op="!" class="btn btn-outline-secondary tap-btn tap-btn-operator">NOT</button>
            </div>
            <div>
              <label class="form-label mb-1">オペランド（窓）</label>
              <div id="logicOperands" class="d-flex flex-wrap gap-2"></div>
            </div>
          </div>
          <div class="col-12 col-md-5">
            <div class="card">
              <div class="card-body small">
                <div class="d-flex justify-content-between align-items-center mb-2">
                  <div class="fw-semibold">評価結果</div>
                  <div class="d-flex align-items-center gap-2">
                    <span class="text-nowrap">補集合の基準:</span>
                    <select id="logicUniverse" class="form-select form-select-sm w-auto">
                      <option value="1..43">1..43（全数）</option>
                      <option value="active">候補全体（選択窓の和集合）</option>
                    </select>
                  </div>
                </div>
                <div id="logicStatus" class="text-muted mb-2">式を入力して「評価」を押してください。</div>
                <div id="logicResult" class="d-flex flex-wrap gap-1"></div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <!-- ▲▲ 論理合成(β) ▲▲ -->
    </section>

    <!-- 組合せ統計 -->
    <section id="sectionStats" class="bg-white rounded-xl shadow p-4 md:p-6 space-y-4 section-hidden">
      <h2 class="font-semibold">組合せ統計：過去データに基づく出現回数</h2>
      <div class="overflow-auto max-h-[60vh] border rounded">
        <table class="min-w-full text-sm">
          <thead class="bg-slate-100 sticky top-0">
            <tr>
              <th class="border px-2 py-1 sticky-th">順位</th>
              <th class="border px-2 py-1 sticky-th">組合せ</th>
              <th class="border px-2 py-1 sticky-th">回数</th>
            </tr>
          </thead>
          <tbody id="statsTbody"></tbody>
        </table>
      </div>
      <p id="statsStatus" class="text-sm text-slate-500"></p>
      <div class="flex flex-wrap items-end gap-3 text-sm">
        <label>組合せサイズ
          <select id="combR" class="border rounded px-2 py-1">
            <option value="1">1</option>
            <option value="2">2</option>
            <option value="3">3</option>
            <option value="4">4</option>
            <option value="5">5</option>
            <option value="6">6</option>
          </select>
        </label>
        <label>順序
          <select id="combDir" class="border rounded px-2 py-1">
            <option value="desc">降順（回数多→少）</option>
            <option value="asc">昇順（回数少→多）</option>
          </select>
        </label>
        <label>表示件数
          <input id="combLimit" type="number" value="200" min="1" class="w-24 border rounded px-2 py-1" />
        </label>
        <button id="runStats" class="ml-auto px-4 py-2 rounded bg-indigo-600 text-white">統計を実行</button>
      </div>
    </section>

    <!-- データ入力（共通） -->
    <section class="bg-white rounded-xl shadow p-4 md:p-6 space-y-4">
      <h2 class="font-semibold">データ入力</h2>
      <textarea id="rawData" class="w-full h-52 p-3 border rounded mono" placeholder="1行=1開催回（6個の数字: スペース/カンマ区切り）。最終行が最新回になります。"></textarea>
      <div class="flex flex-wrap items-center gap-3 text-sm">
        <input id="headerCheckbox" type="checkbox" class="rounded" />
        <label for="headerCheckbox">先頭行はヘッダー（無視）</label>
        <button id="loadSample" class="ml-auto btn btn-outline-secondary btn-sm">サンプル読込</button>
        <label class="btn btn-outline-secondary btn-sm">CSV読込
          <input id="fileInput" type="file" accept=".csv,.txt" class="hidden" />
        </label>
        <button id="clearData" class="btn btn-outline-secondary btn-sm">クリア</button>
      </div>
      <p class="text-xs text-slate-500">※ フロントエンドのみで動作。スマホでも操作しやすいUIに調整済み。</p>
    </section>
  </main>
  <footer class="text-center text-muted py-4">© 2025 ロト6 周期性分析 v2</footer>

  <script>
    // ============== 共通ユーティリティ ==============
    function parseLines(text, skipHeader=false) {
      const lines = text.split(/\r?\n/).map(l => l.trim());
      const start = skipHeader ? 1 : 0;
      const draws = [];
      for (let i = start; i < lines.length; i++) {
        const l = lines[i];
        if (!l) continue;
        const tokens = l.replaceAll(/[^0-9,\s]/g, '')
                        .split(/[\s,]+/)
                        .filter(Boolean)
                        .map(Number);
        if (tokens.length === 6 && tokens.every(n => Number.isFinite(n) && n >= 1 && n <= 43)) {
          draws.push(tokens.sort((a,b)=>a-b));
        }
      }
      return draws;
    }
    function countNums(draws) { const m = new Map(); for (const d of draws) for (const n of d) m.set(n, (m.get(n)||0)+1); return m; }
    function pickNums(map, st, ed){ return Array.from(map.entries()).filter(([n,c])=>c>=st&&c<=ed).map(([n])=>n).sort((a,b)=>a-b); }
    function numberChip(n, hi=false){ const el=document.createElement('span'); el.textContent=String(n).padStart(2,'0'); el.className='chip '+(hi?'chip-hi':''); return el; }

    // ============== タブ切替 ==============
    const tabNormal  = document.getElementById('tabNormal');
    const tabShift   = document.getElementById('tabShift');
    const tabPredict = document.getElementById('tabPredict');
    const tabStats   = document.getElementById('tabStats');
    const secNormal  = document.getElementById('sectionNormal');
    const secShift   = document.getElementById('sectionShift');
    const secPredict = document.getElementById('sectionPredict');
    const secStats   = document.getElementById('sectionStats');
    function showNormal(){  tabNormal.classList.add('tab-active'); tabShift.classList.remove('tab-active'); tabPredict.classList.remove('tab-active'); tabStats.classList.remove('tab-active'); secNormal.classList.remove('section-hidden'); secShift.classList.add('section-hidden'); secPredict.classList.add('section-hidden'); secStats.classList.add('section-hidden'); }
    function showShift(){   tabShift.classList.add('tab-active');  tabNormal.classList.remove('tab-active'); tabPredict.classList.remove('tab-active'); tabStats.classList.remove('tab-active'); secShift.classList.remove('section-hidden');  secNormal.classList.add('section-hidden'); secPredict.classList.add('section-hidden'); secStats.classList.add('section-hidden'); }
    function showPredict(){ tabPredict.classList.add('tab-active'); tabNormal.classList.remove('tab-active'); tabShift.classList.remove('tab-active'); tabStats.classList.remove('tab-active'); secPredict.classList.remove('section-hidden'); secNormal.classList.add('section-hidden'); secShift.classList.add('section-hidden'); secStats.classList.add('section-hidden'); }
    function showStats(){   tabStats.classList.add('tab-active');   tabNormal.classList.remove('tab-active'); tabShift.classList.remove('tab-active'); tabPredict.classList.remove('tab-active'); secStats.classList.remove('section-hidden'); secNormal.classList.add('section-hidden'); secShift.classList.add('section-hidden'); secPredict.classList.add('section-hidden'); }
    tabNormal .addEventListener('click', showNormal);
    tabShift  .addEventListener('click', showShift);
    tabPredict.addEventListener('click', showPredict);
    tabStats  .addEventListener('click', showStats);

    // ============== 入力共通UI ==============
    document.getElementById('loadSample').addEventListener('click',()=>{
      const sample=`01 03 07 12 25 36\n04 09 12 18 29 40\n03 07 11 24 31 37\n01 10 14 23 32 38\n02 06 12 19 27 33\n05 08 13 21 28 35\n04 07 12 16 25 30\n03 06 11 17 22 39\n02 09 10 20 34 41\n01 05 12 18 29 36\n04 08 15 23 31 40\n06 09 13 22 27 35\n03 07 12 16 24 37\n02 10 11 21 33 38\n05 08 14 19 26 41\n01 04 12 20 28 39`;
      document.getElementById('rawData').value=sample;
    });
    document.getElementById('fileInput').addEventListener('change', async (e) => {
      const f = e.target.files?.[0];
      if (!f) return;
      try {
        const buf = await f.arrayBuffer();
        let text = '';
        try {
          text = new TextDecoder('utf-8', { fatal: false }).decode(buf);
          const invalid = (text.match(/\uFFFD|�/g) || []).length;
          if (invalid > 3) throw new Error('utf-8 decode issue');
        } catch (_) {
          try { text = new TextDecoder('shift_jis').decode(buf); }
          catch (_) { text = await f.text(); }
        }
        text = text.replace(/^\uFEFF/, '');
        document.getElementById('rawData').value = text;
      } catch (err) {
        console.error(err);
        alert('ファイル読込に失敗しました: ' + err);
      }
    });
    document.getElementById('clearData').addEventListener('click',()=>{ document.getElementById('rawData').value=''; });

    // ============== 通常分析 ==============
    const defaultCandidates=[5,6,7,8,9,10,11,12,13,14,15,16,18,20,21,22,23,24,25,26,27,28,30,32,36,40,45,50];
    const commonSet=[6,9,12,15,18,21,22,23,24,25,26,27,30];
    const rangesBox=document.getElementById('rangesBox');
    function renderRangeChecks(){ rangesBox.innerHTML=''; for(const n of defaultCandidates){ const wrap=document.createElement('label'); wrap.className='inline-flex items-center gap-2 px-2 py-1 rounded-lg border bg-slate-50 hover:bg-slate-100'; wrap.innerHTML=`<input type="checkbox" data-n="${n}" class="rounded"> 直近 <strong>${n}</strong> 回`; rangesBox.appendChild(wrap);} }
    renderRangeChecks();
    document.getElementById('selectCommon').addEventListener('click',()=>{ for(const el of rangesBox.querySelectorAll('input[type="checkbox"]')) el.checked=commonSet.includes(Number(el.dataset.n)); });
    document.getElementById('selectClear').addEventListener('click',()=>{ for(const el of rangesBox.querySelectorAll('input[type="checkbox"]')) el.checked=false; });
    document.getElementById('addRangeBtn').addEventListener('click',()=>{ const val=Number(document.getElementById('addRange').value); if(!Number.isFinite(val)||val<=0) return; if(!defaultCandidates.includes(val)){ defaultCandidates.push(val); defaultCandidates.sort((a,b)=>a-b); renderRangeChecks(); } const el=rangesBox.querySelector(`input[data-n="${val}"]`); if(el) el.checked=true; });

    let barRef=null;
    function drawBar(labels,data){ const ctx=document.getElementById('barChart').getContext('2d'); if(barRef) barRef.destroy(); barRef=new Chart(ctx,{type:'bar', data:{labels, datasets:[{label:'最新回に含まれた個数（的中数）', data}]}, options:{responsive:true, scales:{y:{beginAtZero:true, ticks:{stepSize:1}}}}}); }

    document.getElementById('runNormal').addEventListener('click',()=>{
      const st=Number(document.getElementById('stInput').value||2);
      const ed=Number(document.getElementById('edInput').value||4);
      const skipHeader=document.getElementById('headerCheckbox').checked;
      const draws=parseLines(document.getElementById('rawData').value, skipHeader);
      const status=document.getElementById('normalStatus');
      if(draws.length<2){ status.textContent='データが不足（最低2行: 最新回+過去）'; return; }
      if(st>ed){ status.textContent='st は ed 以下にしてください。'; return; }
      const latest=draws[draws.length-1];
      const latestBox=document.getElementById('latestNumbers'); latestBox.innerHTML=''; latest.forEach(n=>latestBox.appendChild(numberChip(n,true)));
      const selectedN=[...rangesBox.querySelectorAll('input[type="checkbox"]:checked')].map(el=>Number(el.dataset.n)).sort((a,b)=>a-b);
      if(selectedN.length===0){ status.textContent='分析ウィンドウ（直近N回）を1つ以上選択してください。'; return; }
      const labels=[], data=[]; const resList=document.getElementById('resultList'); resList.innerHTML='';
      for(const N of selectedN){
        if(draws.length < N+1){ const p=document.createElement('p'); p.className='text-xs text-rose-600'; p.textContent=`直近${N}回: データ不足でスキップ`; resList.appendChild(p); continue; }
        const subset=draws.slice(0,-1).slice(-N);
        const picked=pickNums(countNums(subset), st, ed);
        const matched=picked.filter(n=>new Set(latest).has(n)).sort((a,b)=>a-b);
        const card=document.createElement('div'); card.className='border rounded-xl p-3 bg-slate-50';
        const head=document.createElement('div'); head.className='font-medium mb-1'; head.textContent=`直近${N}回（抽出: ${st}〜${ed}回）→ 的中 ${matched.length}個`;
        const box=document.createElement('div'); box.className='flex flex-wrap gap-1'; matched.forEach(n=>box.appendChild(numberChip(n,true)));
        card.append(head,box); resList.appendChild(card);
        labels.push(`N=${N}`); data.push(matched.length);
      }
      if(labels.length) drawBar(labels,data);
      status.textContent=`完了: ${labels.length}件のウィンドウを評価しました。`;
    });

    // ============== ずらし検証 ==============
    let shiftChartRef=null; function drawShiftChart(labels,data,N,st,ed){ const ctx=document.getElementById('shiftChart').getContext('2d'); if(shiftChartRef) shiftChartRef.destroy(); shiftChartRef=new Chart(ctx,{type:'line', data:{labels,datasets:[{label:`的中数 (N=${N}, st=${st}, ed=${ed})`, data, fill:false, tension:0.2}]}, options:{responsive:true, scales:{y:{beginAtZero:true, ticks:{stepSize:1}}}}}); }
    document.getElementById('runShift').addEventListener('click',()=>{
      const N=Number(document.getElementById('shiftN').value||6);
      const st=Number(document.getElementById('shiftSt').value||2);
      const ed=Number(document.getElementById('shiftEd').value||4);
      const maxShift=Number(document.getElementById('shiftMax').value||20);
      const skipHeader=document.getElementById('headerCheckbox').checked;
      const draws=parseLines(document.getElementById('rawData').value, skipHeader);
      const tbody=document.querySelector('#shiftTable tbody');
      tbody.innerHTML='';
      const labels=[], data=[];
      if(draws.length < N+1){ document.getElementById('shiftStatus').textContent=`データが不足: 直前${N}回 + 基準回で最低 ${N+1} 行が必要です。`; return; }
      if(st>ed){ document.getElementById('shiftStatus').textContent='st は ed 以下にしてください。'; return; }
      for(let offset=0; offset<=maxShift; offset++){
        const refIdx=draws.length-1-offset; if(refIdx<0) break; const from=refIdx-N; if(from<0) continue;
        const windowDraws=draws.slice(from, refIdx);
        const picked=pickNums(countNums(windowDraws), st, ed);
        const matched=picked.filter(n=>new Set(draws[refIdx]).has(n)).sort((a,b)=>a-b);
        const tr=document.createElement('tr');
        tr.innerHTML=`<td class='border px-2 py-1 text-center'>最新から${offset}回前</td><td class='border px-2 py-1 text-center'>${matched.length}</td><td class='border px-2 py-1'>${matched.map(n=>String(n).padStart(2,'0')).join(', ')}</td>`;
        tbody.appendChild(tr);
        labels.push(`-${offset}`); data.push(matched.length);
      }
      drawShiftChart(labels,data,N,st,ed);
      document.getElementById('shiftStatus').textContent=`${labels.length} 回分を解析しました。`;
    });

    // ============== 予測 v2 ==============
    const predRangesBox=document.getElementById('predRangesBox');
    function renderPredRangeChecks(){ predRangesBox.innerHTML=''; for(const n of defaultCandidates){ const wrap=document.createElement('label'); wrap.className='flex items-center justify-between w-full px-2 py-1 rounded-lg border bg-slate-50 hover:bg-slate-100'; wrap.innerHTML=`<span>直近 <strong>${n}</strong> 回</span><input type=\"checkbox\" data-n=\"${n}\" class=\"rounded\">`; predRangesBox.appendChild(wrap);} }
    renderPredRangeChecks();
    document.getElementById('predSelectCommon').addEventListener('click',()=>{ for(const el of predRangesBox.querySelectorAll('input[type="checkbox"]')) el.checked=commonSet.includes(Number(el.dataset.n)); });
    document.getElementById('predSelectClear') .addEventListener('click',()=>{ for(const el of predRangesBox.querySelectorAll('input[type="checkbox"]')) el.checked=false; });
    document.getElementById('predAddRangeBtn').addEventListener('click',()=>{ const val=Number(document.getElementById('predAddRange').value); if(!Number.isFinite(val)||val<=0) return; if(!defaultCandidates.includes(val)){ defaultCandidates.push(val); defaultCandidates.sort((a,b)=>a-b); renderPredRangeChecks(); } const el=predRangesBox.querySelector(`input[data-n=\"${val}\"]`); if(el) el.checked=true; });

    document.getElementById('andSelectAll').addEventListener('click',()=>{ for(const el of document.querySelectorAll('.and-target')) el.checked=true; });
    document.getElementById('andSelectNone').addEventListener('click',()=>{ for(const el of document.querySelectorAll('.and-target')) el.checked=false; });

    let _perWindow = [];
    let _stats = new Map();

    function sortNumbersByMode(arr, sortMode, stats, sortDir){
      const wc = (n)=> (stats.get(n)?.windowsCount || 0);
      const tc = (n)=> (stats.get(n)?.totalCount   || 0);
      const numAsc  = (a,b)=> a-b;
      const numDesc = (a,b)=> b-a;
      if (sortMode === 'numeric') { arr.sort(sortDir === 'asc' ? numAsc : numDesc); return; }
      function cmp(a,b, keys){ for (const [get, dir] of keys) { const av = get(a), bv = get(b); if (av !== bv) return dir === 'asc' ? (av - bv) : (bv - av); } return sortDir === 'asc' ? (a - b) : (b - a); }
      if (sortMode === 'windowsThenTotal')      arr.sort((a,b)=> cmp(a,b, [[wc, sortDir], [tc, sortDir]]));
      else if (sortMode === 'totalThenWindows') arr.sort((a,b)=> cmp(a,b, [[tc, sortDir], [wc, sortDir]]));
      else                                      arr.sort(sortDir === 'asc' ? numAsc : numDesc);
    }

    function computeStatsFromWindows(perWindow){
      const allNums = new Set();
      for(const w of perWindow) for(const n of w.set) allNums.add(n);
      const stats = new Map();
      for(const n of allNums){ let wcnt=0, tot=0; for(const w of perWindow){ if(w.set.has(n)){ wcnt++; tot += (w.counts.get(n)||0); } } stats.set(n, {windowsCount:wcnt, totalCount:tot}); }
      return { allNums, stats };
    }

    function recalcAll(){
      const status   = document.getElementById('predStatus');
      const andBox   = document.getElementById('predAND');
      const majBox   = document.getElementById('predMAJ');
      const scoreBox = document.getElementById('predSCORES');
      andBox.innerHTML=''; majBox.innerHTML=''; scoreBox.innerHTML='';
      if(!_perWindow.length){ status.textContent='先に「予測を実行」してください。'; return; }
      const sortMode = document.getElementById('sortMode').value;
      const sortDir  = document.getElementById('sortDir').value;
      const k        = Number(document.getElementById('voteK').value||2);
      const { allNums, stats } = computeStatsFromWindows(_perWindow);
      _stats = stats;
      const active = _perWindow.filter(w=>{ const cb=document.getElementById(w.andChkId); return cb && cb.checked; });
      let andSet=null; for(const w of active){ andSet = andSet===null ? new Set(w.set) : new Set([...andSet].filter(x=>w.set.has(x))); }
      if(!active.length) andSet = new Set();
      const andArr=[...andSet]; andArr.sort(sortDir === 'asc' ? (a,b)=>a-b : (a,b)=>b-a);
      andArr.forEach(n=>{ const el=numberChip(n,true); const st=stats.get(n)||{windowsCount:0,totalCount:0}; el.title=`窓出現数:${st.windowsCount} / 総出現数:${st.totalCount}`; andBox.appendChild(el); });
      const majSet = new Set([...allNums].filter(n=> (stats.get(n).windowsCount >= k)));
      const majArr=[...majSet]; majArr.sort(sortDir === 'asc' ? (a,b)=>a-b : (a,b)=>b-a);
      majArr.forEach(n=>{ const el=numberChip(n,true); const st=stats.get(n); el.title=`窓出現数:${st.windowsCount} / 総出現数:${st.totalCount}`; majBox.appendChild(el); });
      const allArr=[...allNums]; sortNumbersByMode(allArr, sortMode, stats, sortDir);
      allArr.forEach(n=>{ const wrap=document.createElement('span'); wrap.className='chip'; const st=stats.get(n); wrap.title=`窓出現数:${st.windowsCount} / 総出現数:${st.totalCount}`; wrap.textContent=String(n).padStart(2,'0'); const sup=document.createElement('sup'); sup.className='ml-1 text-[10px] text-slate-500'; sup.textContent=`w${st.windowsCount}|Σ${st.totalCount}`; wrap.appendChild(sup); scoreBox.appendChild(wrap); });
      status.textContent = `AND対象=${active.length} / AND=${andArr.length} / 多数決=${majArr.length} / 候補=${allArr.length}`;
      try { renderLogicOperands(); } catch(e) {}
    }

    document.getElementById('btnRecalcAND')?.addEventListener('click', recalcAll);
    document.getElementById('sortMode')?.addEventListener('change', recalcAll);
    document.getElementById('sortDir')?.addEventListener('change', recalcAll);
    document.getElementById('voteK')?.addEventListener('change', recalcAll);

    document.getElementById('runPredict').addEventListener('click',()=>{
      const st=Number(document.getElementById('predSt').value||2);
      const ed=Number(document.getElementById('predEd').value||4);
      const k =Number(document.getElementById('voteK').value||2);
      const sortMode=document.getElementById('sortMode').value;
      const sortDir=document.getElementById('sortDir').value;
      const fM=Number(document.getElementById('filterM').value||6);
      const fMin=Number(document.getElementById('filterMin').value||0);
      const fMax=Number(document.getElementById('filterMax').value||99);
      const skipHeader=document.getElementById('headerCheckbox').checked;

      const draws=parseLines(document.getElementById('rawData').value, skipHeader);
      const status=document.getElementById('predStatus');
      const listWrap=document.getElementById('predLists'); listWrap.innerHTML='';
      document.getElementById('predAND').innerHTML='';
      document.getElementById('predMAJ').innerHTML='';
      document.getElementById('predSCORES').innerHTML='';

      if(draws.length<1){ status.textContent='データが不足しています。'; return; }
      if(st>ed){ status.textContent='st は ed 以下にしてください。'; return; }
      const selectedN=[...predRangesBox.querySelectorAll('input[type=\"checkbox\"]:checked')].map(el=>Number(el.dataset.n)).sort((a,b)=>a-b);
      if(selectedN.length===0){ status.textContent='直近N（最新含む）を1つ以上選択してください。'; return; }
      const filterCounts = (draws.length>=fM) ? countNums(draws.slice(-fM)) : countNums(draws);
      const occurInM = (num)=> filterCounts.get(num)||0;
      const perWindow = [];
      for(const N of selectedN){
        if(draws.length < N){ const p=document.createElement('p'); p.className='text-xs text-rose-600'; p.textContent=`直近${N}回: データ不足でスキップ`; listWrap.appendChild(p); continue; }
        const subset=draws.slice(-N);
        const counts=countNums(subset);
        const picked=pickNums(counts, st, ed);
        const filtered = picked.filter(n=>{ const c=occurInM(n); return c>=fMin && c<=fMax; });
        const chkId = `and_${N}_${Math.random().toString(36).slice(2,7)}`;
        const card=document.createElement('div'); card.className='border rounded-xl p-3 bg-slate-50';
        const head=document.createElement('div'); head.className='font-medium mb-1 flex items-center gap-2';
        head.innerHTML = `<label class='inline-flex items-center gap-2'><input type='checkbox' id='${chkId}' class='and-target' checked> AND対象 | 直近${N}回（最新含む）: 出現 ${st}〜${ed} 回 → 候補 ${filtered.length}個</label>`;
        const box=document.createElement('div'); box.className='flex flex-wrap gap-1'; filtered.forEach(n=>box.appendChild(numberChip(n,true)));
        card.append(head, box); listWrap.appendChild(card);
        perWindow.push({ N, set:new Set(filtered), counts, andChkId: chkId });
      }
      if(perWindow.length===0){ status.textContent='有効な窓がありません。条件を見直してください。'; return; }
      _perWindow = perWindow;
      recalcAll();
      status.textContent = `生成: 窓=${perWindow.length}（AND対象=${perWindow.filter(w=> document.getElementById(w.andChkId).checked).length}） / k=${k} / フィルタ: 直近${fM}回の ${fMin}〜${fMax} 回に合致`;
    });

    // ============== 組合せ統計 ==============
    function kCombinations(arr, k){
      const res=[]; const n=arr.length; if(k<1||k>n) return res;
      const idx=Array.from({length:k},(_,i)=>i);
      const pushComb=()=>{ res.push(idx.map(i=>arr[i])); };
      pushComb();
      while(true){ let i=k-1; while(i>=0 && idx[i]===i+n-k) i--; if(i<0) break; idx[i]++; for(let j=i+1;j<k;j++) idx[j]=idx[j-1]+1; pushComb(); }
      return res;
    }

    function runCombStats(){
      const skipHeader=document.getElementById('headerCheckbox').checked;
      const draws=parseLines(document.getElementById('rawData').value, skipHeader);
      const tbody=document.getElementById('statsTbody');
      const status=document.getElementById('statsStatus');
      tbody.innerHTML='';
      if(draws.length===0){ status.textContent='データがありません。下の「データ入力」から読み込んでください。'; return; }
      const r=Number(document.getElementById('combR').value||1);
      const dir=document.getElementById('combDir').value;
      const limit=Number(document.getElementById('combLimit').value||200);

      const counter=new Map();
      for(const draw of draws){
        if(r===1){ for(const n of draw){ const key=String(n).padStart(2,'0'); counter.set(key,(counter.get(key)||0)+1); }
        } else {
          const combs=kCombinations(draw, r);
          for(const c of combs){ const key=c.map(n=>String(n).padStart(2,'0')).join('-'); counter.set(key,(counter.get(key)||0)+1); }
        }
      }
      let arr=[...counter.entries()];
      arr.sort((a,b)=> (dir==='asc' ? a[1]-b[1] : b[1]-a[1]) || (a[0]<b[0]? -1: 1));
      if(limit>0) arr=arr.slice(0, limit);
      let rank=1;
      for(const [key,count] of arr){ const tr=document.createElement('tr'); tr.innerHTML=`<td class='border px-2 py-1 text-center'>${rank++}</td><td class='border px-2 py-1 font-mono'>${key}</td><td class='border px-2 py-1 text-right'>${count}</td>`; tbody.appendChild(tr); }
      status.textContent=`組合せサイズ r=${r} / 一意の組合せ数 ${counter.size} / 表示 ${arr.length} 件（${dir==='asc'?'少ない順':'多い順'}）`;
    }
    document.getElementById('runStats').addEventListener('click', runCombStats);
    document.getElementById('combR').addEventListener('change', runCombStats);
    document.getElementById('combDir').addEventListener('change', runCombStats);
  </script>

  <script>
    // ============== 論理合成(β) ロジック ==============
    function currentUniverse(){
      const mode = document.getElementById('logicUniverse')?.value || '1..43';
      if(mode === '1..43') return new Set(Array.from({length:43}, (_,i)=> i+1));
      const s = new Set();
      for(const w of _perWindow||[]){ for(const n of w.set) s.add(n); }
      return s;
    }
    function setAND(A,B){ const r=new Set(); for(const x of A){ if(B.has(x)) r.add(x); } return r; }
    function setOR(A,B){ const r=new Set(A); for(const x of B) r.add(x); return r; }
    function setDIFF(A,B){ const r=new Set(); for(const x of A){ if(!B.has(x)) r.add(x); } return r; }
    function setNOT(A){ const U=currentUniverse(); return setDIFF(U, A); }

    function tokenize(expr){
      const tokens=[]; let i=0; while(i<expr.length){ const ch=expr[i]; if(/\s/.test(ch)){ i++; continue; } if('()&|-!'.includes(ch)){ tokens.push(ch); i++; continue; } if(/[NWA-Za-z0-9=]/.test(ch)){ let j=i; while(j<expr.length && /[A-Za-z0-9=]/.test(expr[j])) j++; tokens.push(expr.slice(i,j)); i=j; continue; } throw new Error(`不明な文字: ${ch}`); } return tokens; }
    const PREC = { '!':3, '&':2, '|':1, '-':1 };
    const ASSOC= { '!':'right', '&':'left', '|':'left', '-':'left' };
    function toRPN(tokens){ const out=[], op=[]; for(const t of tokens){ if(t==='(') { op.push(t); continue; } if(t===')') { while(op.length && op[op.length-1] !== '(') out.push(op.pop()); if(!op.length) throw new Error('括弧が不正です'); op.pop(); continue; } if(t in PREC){ while(op.length){ const top=op[op.length-1]; if(!(top in PREC)) break; const pTop=PREC[top], pT=PREC[t]; if(pTop>pT || (pTop===pT && ASSOC[t]==='left')) out.push(op.pop()); else break; } op.push(t); continue; } out.push(t); } while(op.length){ const x=op.pop(); if(x==='('||x===')') throw new Error('括弧が不正です'); out.push(x); } return out; }
    function evalRPN(rpn, ctx){
      const st=[];
      for(const t of rpn){
        if(t in PREC){
          if(t==='!'){ const A=st.pop(); if(!A) throw new Error('式エラー: NOTの直前が不足'); st.push(setNOT(A)); continue; }
          const B=st.pop(); const A=st.pop(); if(!A||!B) throw new Error('式エラー: オペランド不足');
          if(t==='&') st.push(setAND(A,B));
          else if(t==='|') st.push(setOR(A,B));
          else if(t==='-') st.push(setDIFF(A,B));
          else throw new Error('未知演算子');
          continue;
        }
        const S = ctx[t]; if(!S) throw new Error(`未知のオペランド: ${t}`); st.push(new Set(S));
      }
      if(st.length!==1) throw new Error('式エラー: 評価に失敗');
      return st[0];
    }
    function renderLogicOperands(){
      const host=document.getElementById('logicOperands'); if(!host) return; host.innerHTML='';
      if(!_perWindow?.length){ host.innerHTML='<span class="text-muted small">まず「予測を実行」してください。</span>'; return; }
      const list=[..._perWindow].sort((a,b)=>a.N-b.N);
      for(const w of list){
        const id=`N=${w.N}`; const btn=document.createElement('button');
        btn.type='button'; btn.className='btn btn-outline-primary tap-btn op-btn';
        btn.textContent=id; btn.title=`窓: 直近${w.N}回の候補（${w.set.size}個）`;
        btn.addEventListener('click',()=>{ const inp=document.getElementById('logicExpr'); inp.value = (inp.value.trim() ? inp.value + ' ' : '') + id; });
        host.appendChild(btn);
      }
    }
    function buildContext(){ const ctx={}; if(!_perWindow) return ctx; for(const w of _perWindow){ ctx[`N=${w.N}`]=w.set; } return ctx; }
    function renderSetChips(set){ const box=document.getElementById('logicResult'); box.innerHTML=''; const arr=[...set].sort((a,b)=>a-b); for(const n of arr){ box.appendChild(numberChip(n,true)); } document.getElementById('logicStatus').textContent = `要素数: ${arr.length}`; }

    document.addEventListener('click', (ev)=>{ const t=ev.target; if(t?.matches('#logicBuilder [data-op]')){ const op=t.getAttribute('data-op'); const inp=document.getElementById('logicExpr'); const sep = inp.value && !inp.value.endsWith('(') && op!=='!' && op!==')' ? ' ' : ''; inp.value += sep + op; inp.focus(); } });
    document.getElementById('logicBack')?.addEventListener('click',()=>{ const inp=document.getElementById('logicExpr'); inp.value = inp.value.trimEnd().slice(0, -1); });
    document.getElementById('logicClear')?.addEventListener('click',()=>{ const inp=document.getElementById('logicExpr'); inp.value=''; document.getElementById('logicResult').innerHTML=''; document.getElementById('logicStatus').textContent='式を入力して「評価」を押してください。'; });
    document.getElementById('logicEval')?.addEventListener('click',()=>{ const expr = document.getElementById('logicExpr').value.trim(); const status = document.getElementById('logicStatus'); if(!expr){ status.textContent='式が空です。'; return; } try{ const tokens = tokenize(expr); const rpn = toRPN(tokens); const ctx = buildContext(); const set = evalRPN(rpn, ctx); renderSetChips(set); status.textContent = '評価に成功しました。'; }catch(e){ status.textContent = 'エラー: ' + e.message; document.getElementById('logicResult').innerHTML=''; } });
  </script>

  <script>
    // ============== Bootstrap スキン適用（既存UIを手早くリッチに） ==============
    function applyBootstrapSkin(){
      document.querySelectorAll('section').forEach(sec=>{ sec.classList.add('border-0'); sec.style.boxShadow = '0 2px 16px rgba(0,0,0,0.06)'; });
      const primaryIds = ['runNormal','runShift','runPredict','runStats','addRangeBtn','predAddRangeBtn'];
      const secondaryIds = ['selectCommon','selectClear','predSelectCommon','predSelectClear','andSelectAll','andSelectNone','btnRecalcAND','loadSample','clearData','logicBack','logicClear','logicEval'];
      primaryIds.forEach(id=>{ const el=document.getElementById(id); if(!el) return; el.classList.add('btn','btn-primary'); el.classList.remove('bg-indigo-600','text-white'); });
      secondaryIds.forEach(id=>{ const el=document.getElementById(id); if(!el) return; el.classList.add('btn','btn-outline-secondary','btn-sm'); });
      document.querySelectorAll('input[type="number"], input[type="text"], textarea').forEach(el=>{ el.classList.add('form-control'); });
      document.querySelectorAll('select').forEach(el=>{ el.classList.add('form-select'); });
      document.querySelectorAll('.chip').forEach(el=>{ el.classList.add('badge','bg-success-subtle','text-success-emphasis','border','border-success-subtle'); el.style.padding='0.45em 0.6em'; el.style.borderRadius='9999px'; });
      const tabs = [ ['tabNormal','sectionNormal'], ['tabShift','sectionShift'], ['tabPredict','sectionPredict'], ['tabStats','sectionStats'] ];
      tabs.forEach(([btnId,secId])=>{ const btn=document.getElementById(btnId); const sec=document.getElementById(secId); btn?.addEventListener('click',()=>{ tabs.forEach(([bId,sId])=>{ const b=document.getElementById(bId); const s=document.getElementById(sId); if(bId===btnId){ b?.classList.add('active'); s?.classList.remove('section-hidden'); } else { b?.classList.remove('active'); s?.classList.add('section-hidden'); } }); }); });
    }
    document.addEventListener('DOMContentLoaded', applyBootstrapSkin);
  </script>
</body>
</html>
