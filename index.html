<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ロト6 周期性分析</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    .mono { font-feature-settings: "tnum" on; }
    .section-hidden { display: none; }
    .chip { padding: 0.125rem 0.5rem; border-radius: 0.5rem; border: 1px solid rgb(226,232,240); background: #f8fafc; }
    .chip-hi { background: #ecfdf5; border-color: #6ee7b7; color: #047857; }
    th.sticky-th { position: sticky; top: 0; background: #f1f5f9; z-index: 1; }
    /* BootstrapとTailwindの共存のため最低限の調整 */
    .btn-outline-primary.active{ color:#fff; background-color:#0d6efd; }
  </style>
  <!-- Bootstrap 5.3 -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <script defer src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
</head>
<body class="bg-slate-50 text-slate-800">
  <header class="bg-white border-b sticky top-0 z-10">
    <div class="max-w-6xl mx-auto px-4 py-3 flex items-center justify-between">
      <h1 class="text-lg md:text-2xl font-bold">ロト6 周期性分析</h1>
      <nav class="text-sm d-flex gap-2">
        <button id="tabNormal"  class="btn btn-outline-primary btn-sm active" type="button">通常分析</button>
        <button id="tabShift"   class="btn btn-outline-primary btn-sm"           type="button">ずらし検証</button>
        <button id="tabPredict" class="btn btn-outline-primary btn-sm"           type="button">予測</button>
        <button id="tabStats"   class="btn btn-outline-primary btn-sm"           type="button">組合せ統計</button>
      </nav>
    </div>
  </header>

  <main id="main" class="max-w-6xl mx-auto px-4 py-6 space-y-6">
    <!-- 通常分析 -->
    <section id="sectionNormal" class="bg-white rounded-xl shadow p-4 md:p-6 space-y-4">
      <h2 class="font-semibold">通常分析：最新回 × 直近N回</h2>
      <div class="grid md:grid-cols-5 gap-6 items-start">
        <div class="md:col-span-3"><canvas id="barChart" height="220"></canvas></div>
        <div class="md:col-span-2 space-y-3">
          <div><h3 class="font-semibold">最新回</h3><div id="latestNumbers" class="flex flex-wrap gap-2"></div></div>
          <div><h3 class="font-semibold">ウィンドウ別の一致</h3><div id="resultList" class="space-y-2 text-sm"></div></div>
        </div>
      </div>
      <p id="normalStatus" class="text-sm text-slate-500"></p>
      <div class="flex flex-wrap gap-3 items-end text-sm">
        <label>st <input id="stInput" type="number" value="2" min="1" class="w-16 border rounded px-2 py-1" /></label>
        <label>ed <input id="edInput" type="number" value="4" min="1" class="w-16 border rounded px-2 py-1" /></label>
        <label>直近N（追加してチェック）
          <input id="addRange" type="number" min="1" class="w-24 border rounded px-2 py-1" placeholder="N回" />
          <button id="addRangeBtn" class="px-3 py-1.5 rounded bg-indigo-600 text-white">追加</button>
        </label>
        <button id="selectCommon" class="px-3 py-1.5 rounded bg-slate-100 hover:bg-slate-200">よく使う</button>
        <button id="selectClear" class="px-3 py-1.5 rounded bg-slate-100 hover:bg-slate-200">全解除</button>
        <button id="runNormal" class="ml-auto px-4 py-2 rounded bg-indigo-600 text-white">通常分析を実行</button>
      </div>
      <div id="rangesBox" class="grid grid-cols-3 gap-2 text-sm"></div>
    </section>

    <!-- ずらし検証 -->
    <section id="sectionShift" class="bg-white rounded-xl shadow p-4 md:p-6 space-y-4 section-hidden">
      <h2 class="font-semibold">ずらし検証：各開催回 × 直前N回</h2>
      <div class="grid md:grid-cols-5 gap-6 items-start">
        <div class="md:col-span-3"><canvas id="shiftChart" height="220"></canvas></div>
        <div class="md:col-span-2 overflow-x-auto">
          <table id="shiftTable" class="min-w-full border text-sm">
            <thead class="bg-slate-100">
              <tr><th class="border px-2 py-1">対象回(最新からx回前)</th><th class="border px-2 py-1">的中数</th><th class="border px-2 py-1">的中数字</th></tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>
      <p id="shiftStatus" class="text-sm text-slate-500"></p>
      <div class="flex flex-wrap gap-3 items-end">
        <label class="text-sm">N（直前回数）<input id="shiftN" type="number" value="6" min="1" class="w-24 border rounded px-2 py-1" /></label>
        <label class="text-sm">最大ずらしX（0=最新回）<input id="shiftMax" type="number" value="20" min="0" class="w-28 border rounded px-2 py-1" /></label>
        <label class="text-sm">st<input id="shiftSt" type="number" value="2" min="1" class="w-20 border rounded px-2 py-1" /></label>
        <label class="text-sm">ed<input id="shiftEd" type="number" value="4" min="1" class="w-20 border rounded px-2 py-1" /></label>
        <button id="runShift" class="ml-auto px-4 py-2 rounded bg-indigo-600 text-white hover:bg-indigo-700">ずらし検証実行</button>
      </div>
    </section>

    <!-- 予測 -->
    <section id="sectionPredict" class="bg-white rounded-xl shadow p-4 md:p-6 space-y-4 section-hidden">
      <h2 class="font-semibold">予測：直近N回（最新回を含む）で st〜ed 回出現 → 次回候補</h2>
      <div class="grid md:grid-cols-5 gap-6 items-start">
        <div class="md:col-span-3 space-y-3" id="predLists"></div>
        <div class="md:col-span-2 space-y-4">
          <div><h3 class="font-semibold flex items-center gap-2">AND（選択したリストの共通）<button id="btnRecalcAND" class="ml-2 px-2 py-1 rounded bg-slate-100 hover:bg-slate-200 text-sm">ANDを再計算</button></h3><div id="predAND" class="flex flex-wrap gap-1"></div></div>
          <div><h3 class="font-semibold">多数決（k本以上の窓で採用）</h3><div id="predMAJ" class="flex flex-wrap gap-1"></div></div>
          <div><h3 class="font-semibold">スコア付き一覧（フィルタ＆並べ替え後）</h3><div id="predSCORES" class="flex flex-wrap gap-1"></div></div>
        </div>
      </div>
      <p id="predStatus" class="text-sm text-slate-500"></p>
      <div class="grid md:grid-cols-3 gap-4">
        <div class="space-y-3 text-sm md:col-span-2">
          <div class="flex flex-wrap gap-3 items-end">
            <label>st <input id="predSt" type="number" value="2" min="1" class="w-16 border rounded px-2 py-1" /></label>
            <label>ed <input id="predEd" type="number" value="4" min="1" class="w-16 border rounded px-2 py-1" /></label>
            <label>直近N（追加してチェック）<input id="predAddRange" type="number" min="1" class="w-24 border rounded px-2 py-1" placeholder="N回" /><button id="predAddRangeBtn" class="px-3 py-1.5 rounded bg-indigo-600 text-white">追加</button></label>
          </div>
          <div class="flex flex-wrap gap-2"><button id="predSelectCommon" class="px-3 py-1.5 rounded bg-slate-100 hover:bg-slate-200">よく使う</button><button id="predSelectClear"  class="px-3 py-1.5 rounded bg-slate-100 hover:bg-slate-200">全解除</button><button id="runPredict" class="ml-auto px-4 py-2 rounded bg-indigo-600 text-white">予測を実行</button></div>
          <div id="predRangesBox" class="grid grid-cols-2 md:grid-cols-4 gap-2 text-sm"></div>
        </div>
        <div class="space-y-3 text-sm">
          <div class="flex flex-wrap gap-3 items-end"><label>AND 対象（チェックの付いたNだけ）<button id="andSelectAll" class="ml-2 px-2 py-1 rounded bg-slate-100 hover:bg-slate-200">全選択</button><button id="andSelectNone" class="ml-1 px-2 py-1 rounded bg-slate-100 hover:bg-slate-200">全解除</button></label></div>
          <div class="space-y-2">
            <div class="flex items-end gap-3"><label class="flex items-center gap-2">多数決しきい値 k（k本以上の窓で採用）<input id="voteK" type="number" value="2" min="1" class="w-24 border rounded px-2 py-1" /></label></div>
            <div class="flex flex-wrap gap-3 items-end"><label>並べ替え<select id="sortMode" class="border rounded px-2 py-1"><option value="windowsThenTotal">窓出現数→総出現数→数値</option><option value="totalThenWindows">総出現数→窓出現数→数値</option><option value="numeric">数値昇順</option></select></label></div>
            <div class="flex flex-wrap gap-3 items-end"><label>順序<select id="sortDir" class="border rounded px-2 py-1"><option value="desc">降順</option><option value="asc">昇順</option></select></label></div>
            <div class="space-y-2"><div class="font-medium text-sm">除外フィルタ（直近M回での出現回数に基づく）</div><div class="flex items-center gap-2"><span>直近</span><input id="filterM" type="number" value="6" min="1" class="w-20 border rounded px-2 py-1" /><span>回の範囲で</span></div><div class="flex items-center gap-2"><input id="filterMin" type="number" value="0" min="0" class="w-20 border rounded px-2 py-1" /><span>～</span><input id="filterMax" type="number" value="99" min="0" class="w-20 border rounded px-2 py-1" /><span>回 以外を除外</span></div></div>
          </div>
        </div>
      </div>
    </section>

    <!-- 組合せ統計 -->
    <section id="sectionStats" class="bg-white rounded-xl shadow p-4 md:p-6 space-y-4 section-hidden">
      <h2 class="font-semibold">組合せ統計：過去データに基づく出現回数</h2>
      <!-- 結果（先） -->
      <div class="overflow-auto max-h-[60vh] border rounded">
        <table class="min-w-full text-sm">
          <thead class="bg-slate-100 sticky top-0">
            <tr>
              <th class="border px-2 py-1 sticky-th">順位</th>
              <th class="border px-2 py-1 sticky-th">組合せ</th>
              <th class="border px-2 py-1 sticky-th">回数</th>
            </tr>
          </thead>
          <tbody id="statsTbody"></tbody>
        </table>
      </div>
      <p id="statsStatus" class="text-sm text-slate-500"></p>
      <!-- 条件（後） -->
      <div class="flex flex-wrap items-end gap-3 text-sm">
        <label>組合せサイズ
          <select id="combR" class="border rounded px-2 py-1">
            <option value="1">1</option>
            <option value="2">2</option>
            <option value="3">3</option>
            <option value="4">4</option>
            <option value="5">5</option>
            <option value="6">6</option>
          </select>
        </label>
        <label>順序
          <select id="combDir" class="border rounded px-2 py-1">
            <option value="desc">降順（回数多→少）</option>
            <option value="asc">昇順（回数少→多）</option>
          </select>
        </label>
        <label>表示件数
          <input id="combLimit" type="number" value="200" min="1" class="w-24 border rounded px-2 py-1" />
        </label>
        <button id="runStats" class="ml-auto px-4 py-2 rounded bg-indigo-600 text-white">統計を実行</button>
      </div>
    </section>

    <!-- データ入力（共通） -->
    <section class="bg-white rounded-xl shadow p-4 md:p-6 space-y-4">
      <h2 class="font-semibold">データ入力</h2>
      <textarea id="rawData" class="w-full h-52 p-3 border rounded mono" placeholder="1行=1開催回（6個の数字: スペース/カンマ区切り）。最終行が最新回になります。"></textarea>
      <div class="flex flex-wrap items-center gap-3 text-sm">
        <input id="headerCheckbox" type="checkbox" class="rounded" />
        <label for="headerCheckbox">先頭行はヘッダー（無視）</label>
        <button id="loadSample" class="ml-auto px-3 py-1.5 rounded bg-slate-100 hover:bg-slate-200">サンプル読込</button>
        <label class="px-3 py-1.5 rounded-lg bg-slate-100 hover:bg-slate-200 cursor-pointer">CSV読込
          <input id="fileInput" type="file" accept=".csv,.txt" class="hidden" />
        </label>
        <button id="clearData" class="px-3 py-1.5 rounded bg-slate-100 hover:bg-slate-200">クリア</button>
      </div>
      <p class="text-xs text-slate-500">※ GitHub Pages でも動作するよう、フロントエンドのみで完結しています。</p>
    </section>
  </main>
  <footer class="text-center text-muted py-4">© 2025 ロト6 周期性分析</footer>

  <script>
    // ============== 共通ユーティリティ ==============
    function parseLines(text, skipHeader=false) {
      const lines = text.split(/\r?\n/).map(l => l.trim());
      const start = skipHeader ? 1 : 0;
      const draws = [];
      for (let i = start; i < lines.length; i++) {
        const l = lines[i];
        if (!l) continue;
        const tokens = l.replaceAll(/[^0-9,\s]/g, '')
                        .split(/[\s,]+/)
                        .filter(Boolean)
                        .map(Number);
        if (tokens.length === 6 && tokens.every(n => Number.isFinite(n) && n >= 1 && n <= 43)) {
          draws.push(tokens.sort((a,b)=>a-b));
        }
      }
      return draws;
    }
    function countNums(draws) { const m = new Map(); for (const d of draws) for (const n of d) m.set(n, (m.get(n)||0)+1); return m; }
    function pickNums(map, st, ed){ return Array.from(map.entries()).filter(([n,c])=>c>=st&&c<=ed).map(([n])=>n).sort((a,b)=>a-b); }
    function numberChip(n, hi=false){ const el=document.createElement('span'); el.textContent=String(n).padStart(2,'0'); el.className='chip '+(hi?'chip-hi':''); return el; }

    // ============== タブ切替 ==============
    const tabNormal  = document.getElementById('tabNormal');
    const tabShift   = document.getElementById('tabShift');
    const tabPredict = document.getElementById('tabPredict');
    const tabStats   = document.getElementById('tabStats');
    const secNormal  = document.getElementById('sectionNormal');
    const secShift   = document.getElementById('sectionShift');
    const secPredict = document.getElementById('sectionPredict');
    const secStats   = document.getElementById('sectionStats');
    function showNormal(){  tabNormal.classList.add('tab-active'); tabShift.classList.remove('tab-active'); tabPredict.classList.remove('tab-active'); tabStats.classList.remove('tab-active'); secNormal.classList.remove('section-hidden'); secShift.classList.add('section-hidden'); secPredict.classList.add('section-hidden'); secStats.classList.add('section-hidden'); }
    function showShift(){   tabShift.classList.add('tab-active');  tabNormal.classList.remove('tab-active'); tabPredict.classList.remove('tab-active'); tabStats.classList.remove('tab-active'); secShift.classList.remove('section-hidden');  secNormal.classList.add('section-hidden'); secPredict.classList.add('section-hidden'); secStats.classList.add('section-hidden'); }
    function showPredict(){ tabPredict.classList.add('tab-active'); tabNormal.classList.remove('tab-active'); tabShift.classList.remove('tab-active'); tabStats.classList.remove('tab-active'); secPredict.classList.remove('section-hidden'); secNormal.classList.add('section-hidden'); secShift.classList.add('section-hidden'); secStats.classList.add('section-hidden'); }
    function showStats(){   tabStats.classList.add('tab-active');   tabNormal.classList.remove('tab-active'); tabShift.classList.remove('tab-active'); tabPredict.classList.remove('tab-active'); secStats.classList.remove('section-hidden'); secNormal.classList.add('section-hidden'); secShift.classList.add('section-hidden'); secPredict.classList.add('section-hidden'); }
    tabNormal .addEventListener('click', showNormal);
    tabShift  .addEventListener('click', showShift);
    tabPredict.addEventListener('click', showPredict);
    tabStats  .addEventListener('click', showStats);

    // ============== 入力共通UI ==============
    document.getElementById('loadSample').addEventListener('click',()=>{
      const sample=`01 03 07 12 25 36\n04 09 12 18 29 40\n03 07 11 24 31 37\n01 10 14 23 32 38\n02 06 12 19 27 33\n05 08 13 21 28 35\n04 07 12 16 25 30\n03 06 11 17 22 39\n02 09 10 20 34 41\n01 05 12 18 29 36\n04 08 15 23 31 40\n06 09 13 22 27 35\n03 07 12 16 24 37\n02 10 11 21 33 38\n05 08 14 19 26 41\n01 04 12 20 28 39`;
      document.getElementById('rawData').value=sample;
    });
    document.getElementById('fileInput').addEventListener('change', async (e) => {
      const f = e.target.files?.[0];
      if (!f) return;
      try {
        const buf = await f.arrayBuffer();
        let text = '';
        try {
          text = new TextDecoder('utf-8', { fatal: false }).decode(buf);
          const invalid = (text.match(/\uFFFD|�/g) || []).length;
          if (invalid > 3) throw new Error('utf-8 decode issue');
        } catch (_) {
          try { text = new TextDecoder('shift_jis').decode(buf); }
          catch (_) { text = await f.text(); }
        }
        // BOM 除去
        text = text.replace(/^\uFEFF/, '');
        document.getElementById('rawData').value = text;
      } catch (err) {
        console.error(err);
        alert('ファイル読込に失敗しました: ' + err);
      }
    });
    document.getElementById('clearData').addEventListener('click',()=>{ document.getElementById('rawData').value=''; });

    // ============== 通常分析 ==============
    const defaultCandidates=[5,6,7,8,9,10,11,12,13,14,15,16,18,20,21,22,23,24,25,26,27,28,30,32,36,40,45,50];
    const commonSet=[6,9,12,15,18,21,22,23,24,25,26,27,30];
    const rangesBox=document.getElementById('rangesBox');
    function renderRangeChecks(){ rangesBox.innerHTML=''; for(const n of defaultCandidates){ const wrap=document.createElement('label'); wrap.className='inline-flex items-center gap-2 px-2 py-1 rounded-lg border bg-slate-50 hover:bg-slate-100'; wrap.innerHTML=`<input type="checkbox" data-n="${n}" class="rounded"> 直近 <strong>${n}</strong> 回`; rangesBox.appendChild(wrap);} }
    renderRangeChecks();
    document.getElementById('selectCommon').addEventListener('click',()=>{ for(const el of rangesBox.querySelectorAll('input[type="checkbox"]')) el.checked=commonSet.includes(Number(el.dataset.n)); });
    document.getElementById('selectClear').addEventListener('click',()=>{ for(const el of rangesBox.querySelectorAll('input[type="checkbox"]')) el.checked=false; });
    document.getElementById('addRangeBtn').addEventListener('click',()=>{ const val=Number(document.getElementById('addRange').value); if(!Number.isFinite(val)||val<=0) return; if(!defaultCandidates.includes(val)){ defaultCandidates.push(val); defaultCandidates.sort((a,b)=>a-b); renderRangeChecks(); } const el=rangesBox.querySelector(`input[data-n="${val}"]`); if(el) el.checked=true; });

    let barRef=null;
    function drawBar(labels,data){ const ctx=document.getElementById('barChart').getContext('2d'); if(barRef) barRef.destroy(); barRef=new Chart(ctx,{type:'bar', data:{labels, datasets:[{label:'最新回に含まれた個数（的中数）', data}]}, options:{responsive:true, scales:{y:{beginAtZero:true, ticks:{stepSize:1}}}}}); }

    document.getElementById('runNormal').addEventListener('click',()=>{
      const st=Number(document.getElementById('stInput').value||2);
      const ed=Number(document.getElementById('edInput').value||4);
      const skipHeader=document.getElementById('headerCheckbox').checked;
      const draws=parseLines(document.getElementById('rawData').value, skipHeader);
      const status=document.getElementById('normalStatus');
      if(draws.length<2){ status.textContent='データが不足（最低2行: 最新回+過去）'; return; }
      if(st>ed){ status.textContent='st は ed 以下にしてください。'; return; }
      const latest=draws[draws.length-1];
      const latestBox=document.getElementById('latestNumbers'); latestBox.innerHTML=''; latest.forEach(n=>latestBox.appendChild(numberChip(n,true)));
      const selectedN=[...rangesBox.querySelectorAll('input[type="checkbox"]:checked')].map(el=>Number(el.dataset.n)).sort((a,b)=>a-b);
      if(selectedN.length===0){ status.textContent='分析ウィンドウ（直近N回）を1つ以上選択してください。'; return; }
      const labels=[], data=[]; const resList=document.getElementById('resultList'); resList.innerHTML='';
      for(const N of selectedN){
        if(draws.length < N+1){ const p=document.createElement('p'); p.className='text-xs text-rose-600'; p.textContent=`直近${N}回: データ不足でスキップ`; resList.appendChild(p); continue; }
        const subset=draws.slice(0,-1).slice(-N);
        const picked=pickNums(countNums(subset), st, ed);
        const matched=picked.filter(n=>new Set(latest).has(n)).sort((a,b)=>a-b);
        const card=document.createElement('div'); card.className='border rounded-xl p-3 bg-slate-50';
        const head=document.createElement('div'); head.className='font-medium mb-1'; head.textContent=`直近${N}回（抽出: ${st}〜${ed}回）→ 的中 ${matched.length}個`;
        const box=document.createElement('div'); box.className='flex flex-wrap gap-1'; matched.forEach(n=>box.appendChild(numberChip(n,true)));
        card.append(head,box); resList.appendChild(card);
        labels.push(`N=${N}`); data.push(matched.length);
      }
      if(labels.length) drawBar(labels,data);
      status.textContent=`完了: ${labels.length}件のウィンドウを評価しました。`;
    });

    // ============== ずらし検証 ==============
    let shiftChartRef=null; function drawShiftChart(labels,data,N,st,ed){ const ctx=document.getElementById('shiftChart').getContext('2d'); if(shiftChartRef) shiftChartRef.destroy(); shiftChartRef=new Chart(ctx,{type:'line', data:{labels,datasets:[{label:`的中数 (N=${N}, st=${st}, ed=${ed})`, data, fill:false, tension:0.2}]}, options:{responsive:true, scales:{y:{beginAtZero:true, ticks:{stepSize:1}}}}}); }
    document.getElementById('runShift').addEventListener('click',()=>{
      const N=Number(document.getElementById('shiftN').value||6);
      const st=Number(document.getElementById('shiftSt').value||2);
      const ed=Number(document.getElementById('shiftEd').value||4);
      const maxShift=Number(document.getElementById('shiftMax').value||20);
      const skipHeader=document.getElementById('headerCheckbox').checked;
      const draws=parseLines(document.getElementById('rawData').value, skipHeader);
      const tbody=document.querySelector('#shiftTable tbody');
      tbody.innerHTML='';
      const labels=[], data=[];
      if(draws.length < N+1){ document.getElementById('shiftStatus').textContent=`データが不足: 直前${N}回 + 基準回で最低 ${N+1} 行が必要です。`; return; }
      if(st>ed){ document.getElementById('shiftStatus').textContent='st は ed 以下にしてください。'; return; }
      for(let offset=0; offset<=maxShift; offset++){
        const refIdx=draws.length-1-offset; if(refIdx<0) break; const from=refIdx-N; if(from<0) continue;
        const windowDraws=draws.slice(from, refIdx);
        const picked=pickNums(countNums(windowDraws), st, ed);
        const matched=picked.filter(n=>new Set(draws[refIdx]).has(n)).sort((a,b)=>a-b);
        const tr=document.createElement('tr');
        tr.innerHTML=`<td class='border px-2 py-1 text-center'>最新から${offset}回前</td><td class='border px-2 py-1 text-center'>${matched.length}</td><td class='border px-2 py-1'>${matched.map(n=>String(n).padStart(2,'0')).join(', ')}</td>`;
        tbody.appendChild(tr);
        labels.push(`-${offset}`); data.push(matched.length);
      }
      drawShiftChart(labels,data,N,st,ed);
      document.getElementById('shiftStatus').textContent=`${labels.length} 回分を解析しました。`;
    });

    // ============== 予測 ==============
    const predRangesBox=document.getElementById('predRangesBox');
    function renderPredRangeChecks(){ predRangesBox.innerHTML=''; for(const n of defaultCandidates){ const wrap=document.createElement('label'); wrap.className='flex items-center justify-between w-full px-2 py-1 rounded-lg border bg-slate-50 hover:bg-slate-100'; wrap.innerHTML=`<span>直近 <strong>${n}</strong> 回</span><input type=\"checkbox\" data-n=\"${n}\" class=\"rounded\">`; predRangesBox.appendChild(wrap);} }
    renderPredRangeChecks();
    document.getElementById('predSelectCommon').addEventListener('click',()=>{ for(const el of predRangesBox.querySelectorAll('input[type="checkbox"]')) el.checked=commonSet.includes(Number(el.dataset.n)); });
    document.getElementById('predSelectClear') .addEventListener('click',()=>{ for(const el of predRangesBox.querySelectorAll('input[type="checkbox"]')) el.checked=false; });
    document.getElementById('predAddRangeBtn').addEventListener('click',()=>{ const val=Number(document.getElementById('predAddRange').value); if(!Number.isFinite(val)||val<=0) return; if(!defaultCandidates.includes(val)){ defaultCandidates.push(val); defaultCandidates.sort((a,b)=>a-b); renderPredRangeChecks(); } const el=predRangesBox.querySelector(`input[data-n="${val}"]`); if(el) el.checked=true; });

    document.getElementById('andSelectAll').addEventListener('click',()=>{ for(const el of document.querySelectorAll('.and-target')) el.checked=true; });
    document.getElementById('andSelectNone').addEventListener('click',()=>{ for(const el of document.querySelectorAll('.and-target')) el.checked=false; });

    let _perWindow = [];
    let _stats = new Map();

    function sortNumbersByMode(arr, sortMode, stats, sortDir){
      const wc = (n)=> (stats.get(n)?.windowsCount || 0);
      const tc = (n)=> (stats.get(n)?.totalCount   || 0);
      const numAsc  = (a,b)=> a-b;
      const numDesc = (a,b)=> b-a;
      if (sortMode === 'numeric') { arr.sort(sortDir === 'asc' ? numAsc : numDesc); return; }
      function cmp(a,b, keys){ for (const [get, dir] of keys) { const av = get(a), bv = get(b); if (av !== bv) return dir === 'asc' ? (av - bv) : (bv - av); } return sortDir === 'asc' ? (a - b) : (b - a); }
      if (sortMode === 'windowsThenTotal')      arr.sort((a,b)=> cmp(a,b, [[wc, sortDir], [tc, sortDir]]));
      else if (sortMode === 'totalThenWindows') arr.sort((a,b)=> cmp(a,b, [[tc, sortDir], [wc, sortDir]]));
      else                                      arr.sort(sortDir === 'asc' ? numAsc : numDesc);
    }

    function computeStatsFromWindows(perWindow){
      const allNums = new Set();
      for(const w of perWindow) for(const n of w.set) allNums.add(n);
      const stats = new Map();
      for(const n of allNums){ let wcnt=0, tot=0; for(const w of perWindow){ if(w.set.has(n)){ wcnt++; tot += (w.counts.get(n)||0); } } stats.set(n, {windowsCount:wcnt, totalCount:tot}); }
      return { allNums, stats };
    }

    function recalcAll(){
      const status   = document.getElementById('predStatus');
      const andBox   = document.getElementById('predAND');
      const majBox   = document.getElementById('predMAJ');
      const scoreBox = document.getElementById('predSCORES');
      andBox.innerHTML=''; majBox.innerHTML=''; scoreBox.innerHTML='';
      if(!_perWindow.length){ status.textContent='先に「予測を実行」してください。'; return; }
      const sortMode = document.getElementById('sortMode').value;
      const sortDir  = document.getElementById('sortDir').value;
      const k        = Number(document.getElementById('voteK').value||2);
      const { allNums, stats } = computeStatsFromWindows(_perWindow);
      _stats = stats;
      const active = _perWindow.filter(w=>{ const cb=document.getElementById(w.andChkId); return cb && cb.checked; });
      let andSet=null; for(const w of active){ andSet = andSet===null ? new Set(w.set) : new Set([...andSet].filter(x=>w.set.has(x))); }
      if(!active.length) andSet = new Set();
      const andArr=[...andSet]; andArr.sort(sortDir === 'asc' ? (a,b)=>a-b : (a,b)=>b-a);
      andArr.forEach(n=>{ const el=numberChip(n,true); const st=stats.get(n)||{windowsCount:0,totalCount:0}; el.title=`窓出現数:${st.windowsCount} / 総出現数:${st.totalCount}`; andBox.appendChild(el); });
      const majSet = new Set([...allNums].filter(n=> (stats.get(n).windowsCount >= k)));
      const majArr=[...majSet]; majArr.sort(sortDir === 'asc' ? (a,b)=>a-b : (a,b)=>b-a);
      majArr.forEach(n=>{ const el=numberChip(n,true); const st=stats.get(n); el.title=`窓出現数:${st.windowsCount} / 総出現数:${st.totalCount}`; majBox.appendChild(el); });
      const allArr=[...allNums]; sortNumbersByMode(allArr, sortMode, stats, sortDir);
      allArr.forEach(n=>{ const wrap=document.createElement('span'); wrap.className='chip'; const st=stats.get(n); wrap.title=`窓出現数:${st.windowsCount} / 総出現数:${st.totalCount}`; wrap.textContent=String(n).padStart(2,'0'); const sup=document.createElement('sup'); sup.className='ml-1 text-[10px] text-slate-500'; sup.textContent=`w${st.windowsCount}|Σ${st.totalCount}`; wrap.appendChild(sup); scoreBox.appendChild(wrap); });
      status.textContent = `AND対象=${active.length} / AND=${andArr.length} / 多数決=${majArr.length} / 候補=${allArr.length}`;
    }

    document.getElementById('btnRecalcAND')?.addEventListener('click', recalcAll);
    document.getElementById('sortMode')?.addEventListener('change', recalcAll);
    document.getElementById('sortDir')?.addEventListener('change', recalcAll);
    document.getElementById('voteK')?.addEventListener('change', recalcAll);

    document.getElementById('runPredict').addEventListener('click',()=>{
      const st=Number(document.getElementById('predSt').value||2);
      const ed=Number(document.getElementById('predEd').value||4);
      const k =Number(document.getElementById('voteK').value||2);
      const sortMode=document.getElementById('sortMode').value;
      const sortDir=document.getElementById('sortDir').value;
      const fM=Number(document.getElementById('filterM').value||6);
      const fMin=Number(document.getElementById('filterMin').value||0);
      const fMax=Number(document.getElementById('filterMax').value||99);
      const skipHeader=document.getElementById('headerCheckbox').checked;

      const draws=parseLines(document.getElementById('rawData').value, skipHeader);
      const status=document.getElementById('predStatus');
      const listWrap=document.getElementById('predLists'); listWrap.innerHTML='';
      document.getElementById('predAND').innerHTML='';
      document.getElementById('predMAJ').innerHTML='';
      document.getElementById('predSCORES').innerHTML='';

      if(draws.length<1){ status.textContent='データが不足しています。'; return; }
      if(st>ed){ status.textContent='st は ed 以下にしてください。'; return; }
      const selectedN=[...predRangesBox.querySelectorAll('input[type="checkbox"]:checked')].map(el=>Number(el.dataset.n)).sort((a,b)=>a-b);
      if(selectedN.length===0){ status.textContent='直近N（最新含む）を1つ以上選択してください。'; return; }
      const filterCounts = (draws.length>=fM) ? countNums(draws.slice(-fM)) : countNums(draws);
      const occurInM = (num)=> filterCounts.get(num)||0;
      const perWindow = [];
      for(const N of selectedN){
        if(draws.length < N){ const p=document.createElement('p'); p.className='text-xs text-rose-600'; p.textContent=`直近${N}回: データ不足でスキップ`; listWrap.appendChild(p); continue; }
        const subset=draws.slice(-N);
        const counts=countNums(subset);
        const picked=pickNums(counts, st, ed);
        const filtered = picked.filter(n=>{ const c=occurInM(n); return c>=fMin && c<=fMax; });
        const chkId = `and_${N}_${Math.random().toString(36).slice(2,7)}`;
        const card=document.createElement('div'); card.className='border rounded-xl p-3 bg-slate-50';
        const head=document.createElement('div'); head.className='font-medium mb-1 flex items-center gap-2';
        head.innerHTML = `<label class='inline-flex items-center gap-2'><input type='checkbox' id='${chkId}' class='and-target' checked> AND対象 | 直近${N}回（最新含む）: 出現 ${st}〜${ed} 回 → 候補 ${filtered.length}個</label>`;
        const box=document.createElement('div'); box.className='flex flex-wrap gap-1'; filtered.forEach(n=>box.appendChild(numberChip(n,true)));
        card.append(head, box); listWrap.appendChild(card);
        perWindow.push({ N, set:new Set(filtered), counts, andChkId: chkId });
      }
      if(perWindow.length===0){ status.textContent='有効な窓がありません。条件を見直してください。'; return; }
      _perWindow = perWindow; // 保存
      recalcAll();
      status.textContent = `生成: 窓=${perWindow.length}（AND対象=${perWindow.filter(w=> document.getElementById(w.andChkId).checked).length}） / k=${k} / フィルタ: 直近${fM}回の ${fMin}〜${fMax} 回に合致`;
    });

    // ============== 組合せ統計 ==============
    function kCombinations(arr, k){
      const res=[]; const n=arr.length; if(k<1||k>n) return res;
      const idx=Array.from({length:k},(_,i)=>i);
      const pushComb=()=>{ res.push(idx.map(i=>arr[i])); };
      pushComb();
      while(true){ let i=k-1; while(i>=0 && idx[i]===i+n-k) i--; if(i<0) break; idx[i]++; for(let j=i+1;j<k;j++) idx[j]=idx[j-1]+1; pushComb(); }
      return res;
    }

    function runCombStats(){
      const skipHeader=document.getElementById('headerCheckbox').checked;
      const draws=parseLines(document.getElementById('rawData').value, skipHeader);
      const tbody=document.getElementById('statsTbody');
      const status=document.getElementById('statsStatus');
      tbody.innerHTML='';
      if(draws.length===0){ status.textContent='データがありません。下の「データ入力」から読み込んでください。'; return; }
      const r=Number(document.getElementById('combR').value||1);
      const dir=document.getElementById('combDir').value;
      const limit=Number(document.getElementById('combLimit').value||200);

      const counter=new Map();
      for(const draw of draws){ // draw は昇順
        if(r===1){ for(const n of draw){ const key=String(n).padStart(2,'0'); counter.set(key,(counter.get(key)||0)+1); }
        } else {
          const combs=kCombinations(draw, r);
          for(const c of combs){ const key=c.map(n=>String(n).padStart(2,'0')).join('-'); counter.set(key,(counter.get(key)||0)+1); }
        }
      }
      let arr=[...counter.entries()];
      arr.sort((a,b)=> (dir==='asc' ? a[1]-b[1] : b[1]-a[1]) || (a[0]<b[0]? -1: 1));
      if(limit>0) arr=arr.slice(0, limit);
      let rank=1;
      for(const [key,count] of arr){ const tr=document.createElement('tr'); tr.innerHTML=`<td class='border px-2 py-1 text-center'>${rank++}</td><td class='border px-2 py-1 font-mono'>${key}</td><td class='border px-2 py-1 text-right'>${count}</td>`; tbody.appendChild(tr); }
      status.textContent=`組合せサイズ r=${r} / 一意の組合せ数 ${counter.size} / 表示 ${arr.length} 件（${dir==='asc'?'少ない順':'多い順'}）`;
    }
    document.getElementById('runStats').addEventListener('click', runCombStats);
    document.getElementById('combR').addEventListener('change', runCombStats);
    document.getElementById('combDir').addEventListener('change', runCombStats);
  </script>
<script>
  // ============== Bootstrap スキン適用（既存UIを手早くリッチに） ==============
  function applyBootstrapSkin(){
    // セクションをカード風に
    document.querySelectorAll('section').forEach(sec=>{
      sec.classList.add('border-0');
      sec.style.boxShadow = '0 2px 16px rgba(0,0,0,0.06)';
    });

    // ボタン分類
    const primaryIds = ['runNormal','runShift','runPredict','runStats','addRangeBtn','predAddRangeBtn'];
    const secondaryIds = ['selectCommon','selectClear','predSelectCommon','predSelectClear','andSelectAll','andSelectNone','btnRecalcAND','loadSample','clearData'];

    primaryIds.forEach(id=>{
      const el=document.getElementById(id); if(!el) return;
      el.classList.add('btn','btn-primary'); el.classList.remove('bg-indigo-600','text-white');
    });
    secondaryIds.forEach(id=>{
      const el=document.getElementById(id); if(!el) return;
      el.classList.add('btn','btn-outline-secondary','btn-sm'); el.classList.remove('bg-slate-100','hover:bg-slate-200');
    });

    // ファイル選択ラベルをボタン風に
    const csvLabel = document.querySelector('label[for="fileInput"], label:has(#fileInput)');
    if(csvLabel){ csvLabel.classList.add('btn','btn-outline-secondary','btn-sm'); csvLabel.classList.remove('bg-slate-100'); }

    // 入力/セレクトに form-control / form-select
    document.querySelectorAll('input[type="number"], input[type="text"], textarea').forEach(el=>{
      el.classList.add('form-control');
    });
    document.querySelectorAll('select').forEach(el=>{
      el.classList.add('form-select');
    });

    // チップをBootstrapバッジ風に
    document.querySelectorAll('.chip').forEach(el=>{
      el.classList.add('badge','bg-success-subtle','text-success-emphasis','border','border-success-subtle');
      el.style.padding='0.45em 0.6em';
      el.style.borderRadius='9999px';
    });

    // タブのアクティブ切替（見た目）
    const tabs = [
      ['tabNormal','sectionNormal'],
      ['tabShift','sectionShift'],
      ['tabPredict','sectionPredict'],
      ['tabStats','sectionStats']
    ];
    tabs.forEach(([btnId,secId])=>{
      const btn=document.getElementById(btnId);
      const sec=document.getElementById(secId);
      btn?.addEventListener('click',()=>{
        tabs.forEach(([bId,sId])=>{
          const b=document.getElementById(bId); const s=document.getElementById(sId);
          if(bId===btnId){ b?.classList.add('active'); s?.classList.remove('section-hidden'); }
          else { b?.classList.remove('active'); s?.classList.add('section-hidden'); }
        });
      });
    });
  }
  // DOM構築後に適用
  document.addEventListener('DOMContentLoaded', applyBootstrapSkin);
</script>
</body>
</html>
